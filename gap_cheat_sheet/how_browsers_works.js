//        https://habr.com/ru/post/174057/
// оно же https://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/#The_browsers_we_will_talk_about

// таблица стилей по умолчанию
// https://www.w3.org/TR/CSS2/sample.html

// - получение по сети файлов
// - парсинг HTML, CSS
//      - лексический
//      - синтаксический анализ
// - формирование DOM Tree и Style Rules
// - объединение того и этого 
//      формирование Render Tree / Frame Tree
//      в этом же месте где-то происходит reflow
// - Painting
//      repaint
// - вывод на экран

// Оптимизация бразузера помогает быстрее выводить результат на экран
// поэтому вывод на экран может начаться еще до окончания 
// парсинга файлов со всеми вытекающими последствиями
// поэтому reflow и repaint это как основной цикл работы при формировании
// страницы

// Document Type Definition - формальный стандарт определения HTML
// граматика HTML имеет "мягкий" подход и прощает некоторые 
// синтаксические ошибки
// Грамматика HTML не является бесконтекстной,
// поэтому его анализ нельзя выполнить ни с помощью стандартных анализаторов,
// ни с помощью анализаторов XML.

// DOM – объектная модель документа (Document Object Model) 
//      – служит для представления HTML-документа и интерфейса элементов HTML 
//        таким внешним объектам, как код JavaScript.

// Синтаксический анализ кода HTML невозможно выполнить 
// с помощью стандартных нисходящих или восходящих анализаторов т.к.:
//      - Язык имеет "щадящий" характер
//      - В браузерах заложены механизмы обработки некоторых частых ошибок
//      - Цикл синтакичекого анализа характеризуется возможностью
//          повторного вхождения. Т.к. теги скрипта, содержащие
//          document.write могут добавлять новые токены, следовательно
//          исходный код может меняться
// По этим причинам браузеры создают собственных анализаторы HTML

// Синтаксически анализ HTML состоит из:
//      - лексического анализа
//          входная последовательность символов разбирается на токены
//          (открывающиеся и закрывающие теги), так же название и 
//          значение атрибутов
//      - построения дерева
//          лексический анализ обнаруживает токен
//          передает его конструктору дерева и идет за следующим

// После синтаксического анализа документ помечается как интерактивный
// и начинает выполняться анализ отложенных скриптов, которые нужно выполнить
// после завершения анализа документа
// И только после этого состояние документа менятся на готов 
// и вызывается событие load
// 

// Не полный список ошибок которые HTML синтаксический анализатор
// должен исправлять:
//      - Использование добавляемого элемента явно запрещено одним из внешних тегов.
//          В этом случае необходимо закрыть все теги, кроме того, 
//          который запрещает использование данного элемента, 
//          и добавить этот элемент в самом конце.
//      - Элемент нельзя добавить напрямую. Возможно, 
//          автор документа забыл вставить тег между элементами 
//          (или такой тег необязателен).
//          Это касается тегов HTML, HEAD, BODY, TBODY, TR, TD, LI...
//      - Блочный элемент добавлен внутрь строчного.
//          Необходимо закрыть все строчные элементы вплоть до 
//          следующего в иерархии блочного элемента.
//      - Если это не помогает, необходимо закрывать элементы, 
//          пока не появится возможность добавить нужный элемент 
//          или проигнорировать тег.


// CSS
// Для синтаксического анализа СSS применяются текие генераторы как:
//      - Flex (Lex)
//      - Bison (Yacc)

// CSS парсится на объекты SyleSheet содержащие правила CSS
// он содержит селектор и объявление, а так же другие объекты 
// характерные для граматики CSS


// Скрипты
// Веб-доки придерживаются синхронной модели.
// Предполагается что скрипты будут анализироваться и исполняться сразу же
// Как только сиснтаксический анализатор HTML обнаружит тег <script>
// Как только такое происходит, то синтаксический анализ отклазыватеся
// до завершения выполнения скрипта. Но если пометить скрипт тегом:
//      - def то синтаксический анализ можно было выполнить
//          до завершения скрипта
//      - asynchronous чтобы скрипт выполнялся в другом потоке

// Существует "ориентировочный синтаксический анализ"
// это как механизм оптимизации браузеров
// работает в пораллельном потоке пока основном поток занят
// такой анализ не меняет дерево DOM
// лишь обрабатывает ссыдки га вгещгие оесуосы, такие как внешние скрипты,
// таблици стилей и картинки

// Так же существует механизм которые чуть-чуть по разному отрабатывает
// в разных браузерах, но суть его в том, что
// т.к. все таблицы стилей не вносят изменений в DOM дерево, то 
// останавливать анализ документа, чтобы дождать их обработки бессмыслено
// поэтому они выполняются пораллельно. Но...
// скрипт может получить не верную информацию если не все стили проанализированы
// поэтому браузеры приостанавливают работу скрипта если обнаруживают в коде
// стили потенциально содержащиеся в неподгруженной таблице стилей


// Во время построение DOM Tree браузер создает еще одру структуру
// - Render Tree
// В нем визуальные элементы размещаются в том порядке в каком их
// необходимо вывести на экран. Это визуальное представление документа
// Этот механизм служит для того чтобы отрисовка содержания выполнялась
// в правильном порядке

// Каждый объект отображения располагает данными об отрисовке
// самого себя и свох дочерних элементов

// Положение некоторых элементов в Render Tree и в DOM Tree может не
// совпадать по вполне объективным причинам положения на странице

// в FireFox для упрощения вычисления стилей изпользуются
// две структуры:
//      - дерево правил
//      - дерево контекстов стилей
// В Webkit есть объекты стилей, но они не сохраняются в специальном дереве
// Вместо этого узлы DOM указывают на соответствующие стили
// Проще говоря положение узла в ДОМ дереве будет такое же как и в дереве стилей

// Специфичность (веса селекторов)
// Если коротко ты вычисляюся по формуля a-b-c-d где:
//      a - объявление в атрибуте style
//      b - количество атрибутов id внутри селектора
//      с - количество других атрибутов
//              и псевдоклассов внутри селектора
//      в - количество названий элементов и псевтоэлементов
//              внутри сесектора

// Компновка (layout / reflow)
// Процесс рассчета размера и положения элемента
// Компоновка начинается с корневого компонента и выполняется поточно
// сверху вниз справа налево
// обычно за один проход, но иногда в цикле (например таблицы html)

// Любой компонент отображения может при необходимости вызвать 
// метод layout / reflow для дочерних компонентов

// Система "грязных битов" (как способ оптимизации браузеров)
// Если компонент подвергался изменению он и его дети 
// поммечаюется как "грязные"
// dirty - флаг показывает что reflow нужен самому элементу и его детям
// children are dirty - флаг показывает reflow для его детей

// reflow может быть:
//  - глобальный
//      когда к примеру меняется шрифт во всем документе 
//      или ресайз окна
//  - инкрементный когда нужно перещитать только "грязные" элементы

// reflow может быть:
//  - синхронный
//      если это запрос скрипта данных о стиле такие как offsetHeight
//      любая глобальная компоновка
//  - асинхронно
//      инкрементной компоновки
//      такая компоновка помещается в очередь, а затем планировщик
//      вызывает их все вместе
// существует определенная оптимизация resize или ввода текста в инпуты

// Перед повторной отрисовкой старый прямоугольник сохраняется
// в WebKit как растровое изображение, 
// а затем отрисовываются только различия между старым и новым прямоугольником.

// В случает изменния размера компонента reflow вызывается 
// на этом компоненте
// на его детях
// на соседних компонентах его уровня если это необходимо
// после чего вызывается repaint

// но если нужен repaint, то reflow вызываться не будет
// т.к. в этом нет необходимости т.к. размеры компонента не менялись


// Основной поток браузера представляет собой
// цикл событий – бесконечный цикл, 
//      который поддерживает рабочие процессы. 
//      Он ожидает отправки событий (таких как layout и paint), 
//      чтобы их обработать.


// cnavas - он же известный как холст (https://www.w3.org/TR/CSS2/zindex.html)
// пространство, где отображается отформатированная структура, 
// то есть область, в которой браузер отрисовывает содержание.
// Сам по себе холст бесконечен, 
// однако браузеры обычно определяют для него ширину исходя из размеров области просмотра.

// если холст находится внутри другого холста, то он прозрачен, 
// а в остальных случаях окрашен в определенный браузером цвет.
// ------- z-index --------
// canvas -1 0 1 2 <--- user