// Promise - это прием работы с отложенным и/или асинхронным кодом
// который связывает "создающий" код с "потребляющим"
// Создан для того чтобы решить проблему callback hell

// Promise принимает в себя функцию
// код которой выполняется в общем потоке
// до того как конструктор промиса вернет созданный объект ??? надо ли это говорить
// а любое возвращаемое выражение игнорируется

// эта функция принимает в тебя 2 аргумента
// первый аргумент это resolve
// вызывает успешное выполнение промиса
// второй аргумент это reject
// вызывает в случае неуспешного выполнения промиса

// Promise может находиться в трех состояниях
//      - pending (ожидание)
//          начальное состояние, когда промис
//          не исполнен и не отклонент
//      - fulfiled (исполнено)
//          когда промис завершился успешно
//      - rejected (отклонено)
//          когда промис завершился с ошибкой
// состояние примиса видно в свойства status

// у промиса есть метод then()
// он добавляет обработчики промиса
// он принимает в себя два аргумента:
//      - первый аргумент (можно пропустить если поставить null)
//          функция которая принимает в себя
//          переданное значение в случае успешного выполнения промиса
//      - второй аргумент (необязательный)
//          функция которая принимает в себя
//          переданное значение в случае неуспешного выполнения
// then() возвращают так же промис
// следовательно из них можно построить цепочку
// В результате чего может возникнуть проблема с провторением кода
// обработки ошибок. И эту проблему решает наш следующий метод

// catch()
// он принимает в тебя функцию-обрабочик
// которая принимает в себя один аргумент
// который несет информацию о причине неуспешного выполнения промиса
// catch() применяется в конце цепочки из методов then() которые передают
// вознишую ошибку на любом звеньев
// таким образом ошибка обящательно попадет в метод catch

// Promise.all(iterable)
// Promise.allSettled(iterable)
// Promise.race(iterable)

// Promise.reject(reason) // Возвращает промис, отклонённый из-за reason.
// Promise.resolve(value) // Возвращает промис, исполненный с результатом value.


const promise = new Promise(
    (resolve, reject) => {
        setTimeout(() => {
            const random = Math.random();
            if (random > 0.5) {
                resolve('ok all man');
            } else {
                reject('sorry it cant');
            }
        }, 1000);
        console.log('synchronus code working...')
    }
);

promise
    .then(
        result => console.log(result),
        reason => console.log(reason)
    );


promise
    .then(result => console.log(result))
    .catch(reason => console.log(reason));

// ----------------------------------------------

Promise.resolve('ok all man')
    .then(result => console.log(result));

Promise.reject('sorry it cant')
    .catch(reason => console.log(reason));