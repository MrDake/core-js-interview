// Promise - это прием работы с отложенным и/или асинхронным кодом
// который связывает "создающий" код с "потребляющим"
// Создан для того чтобы решить проблему callback hell

// Promise принимает в себя функцию
// код которой выполняется в общем потоке
// до того как конструктор промиса вернет созданный объект ??? надо ли это говорить
// а любое возвращаемое выражение игнорируется

// эта функция принимает в тебя 2 аргумента
// первый аргумент это resolve
// вызывает успешное выполнение промиса
// второй аргумент это reject
// вызывает в случае неуспешного выполнения промиса

// Promise может находиться в трех состояниях
//      - pending (ожидание)
//          начальное состояние, когда промис
//          не исполнен и не отклонент
//      - fulfiled (исполнено)
//          когда промис завершился успешно
//      - rejected (отклонено)
//          когда промис завершился с ошибкой
// состояние примиса видно в свойства status

// у промиса есть метод then()
// он добавляет обработчики промиса
// он принимает в себя два аргумента:
//      - первый аргумент (можно пропустить если поставить null)
//          функция которая принимает в себя
//          переданное значение в случае успешного выполнения промиса
//      - второй аргумент (необязательный)
//          функция которая принимает в себя
//          переданное значение в случае неуспешного выполнения
// then() возвращают так же промис
// следовательно из них можно построить цепочку
// В результате чего может возникнуть проблема с провторением кода
// обработки ошибок. И эту проблему решает наш следующий метод

// catch()
// он принимает в тебя функцию-обрабочик
// которая принимает в себя один аргумент
// который несет информацию о причине неуспешного выполнения промиса
// catch() применяется в конце цепочки из методов then() которые передают
// вознишую ошибку на любом из звеньев
// таким образом ошибка обязательно попадет в метод catch

// Promise.all(iterable)
// Promise.allSettled(iterable)
// Promise.race(iterable)

// Promise.reject(reason) // Возвращает промис, отклонённый из-за reason.
// Promise.resolve(value) // Возвращает промис, исполненный с результатом value.


const promise = new Promise(
    (resolve, reject) => {
        setTimeout(() => {
            const random = Math.random();
            if (random > 0.5) {
                resolve('ok all man');
            } else {
                reject('sorry it cant');
            }
        }, 1000);
        console.log('synchronus code working...')
    }
);

promise
    .then(
        result => console.log(result),
        reason => console.log(reason)
    );


promise
    .then(result => console.log(result))
    .catch(reason => console.log(reason));

// ----------------------------------------------

Promise.resolve('ok all man')
    .then(result => console.log(result));

Promise.reject('sorry it cant')
    .catch(reason => console.log(reason));

// ----------------------------------------------    

// new Promise( function(..){ .. } ) обычно
// называется раскрывающим конструктором (revealing
// constructor). Переданная функция выполняется немедленно
// (без асинхронной задержки, как обратные вызовы then(..)),
// и ей передаются два параметра, которым в нашем случае были
// присвоены имена resolve и reject. Это функции разрешения
// обещания. resolve(..) обычно сигнализирует о выполнении,
// а reject(..) сигнализирует об отказе.

// обещания. resolve(..) обычно сигнализирует о выполнении,
// а reject(..) сигнализирует об отказе.

//  new Promise(null), Promise.all(), Promise.race(42) и т. д. 
// Вы не получите отклоненное обещание, если не будете 
// правильно использовать Promise API для его конструирования!

// Будьте осторожны! Если передать пустой массив методу
// Promise.all([ .. ]), он будет выполнен немедленно, но
// метод Promise.race([ .. ]) зависнет и никогда не разрешится

// патерн "Бездна успеха", когда получает то, что ожидаешь
// а чтобы отловить ошибку надо постарать т.е. использовать
// особые приемы предназначенные для этого

// Если функция some будет выполняться дольше чем указанный delay
// то выполниться timeoutPromise и выдаст исключение 'Timeout'
// Promise.race([some(), timeoutPromise(delay)])
// function timeoutPromise(deley) { 
//     return new Promise((resolve, reject) => {
//         setTimeout(() => {
//             reject( 'Timeout' );
//         }, deley)
//     });
// }


// Обещания работают чуть медленнее, однако взамен вы получаете
// значительную степень доверия, предсказуемость поведения
// и удобные встроенные средства композиции