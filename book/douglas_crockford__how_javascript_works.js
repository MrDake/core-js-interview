//  Дуглос Кроуфорд
console.log('----------------------------------------')

console.log( 0 === -0);

const [p, q] = [false, true];
console.log( !(p && q) === (!p || !q) ); // выражение де Моргана
console.log( !(p || q) === (!p && !q) );

console.log('----------------------------------------')

const arr = [1,2,3,0];
arr[1000] = 'the end (no)';
console.log(arr.length, arr);

const newArr = [100, 200, 0, 1, 5, -500];
const maxValue = Math.max(...newArr);
console.log(maxValue)

console.log(newArr.toString() === newArr.join());

console.log('----------------------------------------')

const my_little_person = {};

// TypeError: Cannot read property 'first' of undefined
// const my_little_first_name = my_little_person.name.first;

// подобный код не выбрасит ошибки вслучает
// отсутствия какого либо из свойств запрошенной
// цепочке объектов
const my_little_first_name = (
    my_little_person
    && my_little_person.name
    && my_little_person.name.first
);

console.log(my_little_first_name)

console.log('----------------------------------------')

const is_mythical = true;
const is_scary = false;
const is_insect = false;

let my_little_value = (
    is_mythical
    ? (
        is_scary
        ? "monster"
        : "unicorn"
    )
    : (
        is_insect
        ? "butterfly"
        : "rainbow"
    )
);

console.log(my_little_value);

console.log('----------------------------------------')

// Смысл компиляции был буквальным:
// выполнение работы за счет сбора информации из других источников.
// Отсюда произошло множество специальных терминов,
// используемых по сей день: ассемблер, компилятор, библиотека, исходник и,
// что важнее всего, вызов

// Грейс Мюррей Хоппер
// разработала список команд под названием A-0. Это был первый компилятор


console.log('----------------------------------------')


// Возвращаемый объект заморожен. Он не может быть испорчен или поврежден. 
// У объекта есть состояние. Переменная counter — закрытое свойство объекта. 
// Обратиться к ней можно только через методы. 
// И нам не нужно использовать this.
// Это весьма важное обстоятельство. 
// Интерфейсом объекта являются исключительно методы. 
// У него очень крепкая оболочка. Мы получаем наилучшую инкапсуляцию.
// Прямого доступа к данным нет. 
// Это весьма качественная модульная конструкция.
function counter_constructor() {
    let counter = 0;

    function up() {
        counter += 1;
        return counter;
    }

    function down() {
        counter -= 1;
   
        return counter;
    }

    return Object.freeze({
        up,
        down
    });
}
// Если жесткий объект должен быть преобразован в строку, 
// нужно включить метод toJSON.
// Иначе JSON.stringify увидит его как пустой объект,
// проигнорировав методы и скрытые данные


// Получается, у нас есть два типа объектов.
// - Жесткие объекты содержат только методы. 
//     Эти объекты защищают целостность данных, содержащихся в замыкании. 
//     Они обеспечивают нас полиморфизмом и инкапсуляцией.
// - Мягкие объекты данных содержат только данные.
//      Поведение у них отсутствует. Это просто удобная коллекция, 
//      с которой могут работать функции


// Событийное программирование
// Событийными функциями являются функции
// которые немедленно возвращают управление,
// возможно еще до завершения востребованной от нее работы,
// а результат будет сообщен через функцию обратного вызова
// или путем отправки сообщения,
// но не в виде немедленного возвращения значения

// Event loop и произошел от "семафоры"
// Семафор был реализован в виде двух функций — P и V.
// Функция P будет пытаться заблокировать критическую секцию,
// блокируя затем код, пытающийся установить блокировку, 
// если эта секция уже заблокирована.
// Функция V будет снимать блокировку, 
// позволяя ожидающему потоку заблокировать критическую секцию и запуститься.
